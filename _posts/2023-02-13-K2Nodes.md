---
layout: post
title: Introduction to K2Node
---

If you want to expose functions from C++ to Blueprint, this post is way too overkill. You should check out [this](https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/TechnicalGuide/ExtendingBlueprints/) resource instead.

During the development of my custom quest editor, Adventure, Iâ€™ve gotten very comfortable with creating custom nodes for both Blueprint and custom graphs. Since there is not much on the topic, I figured I could share my knowledge to the community. 

This blog post will only cover custom **Blueprint nodes** since a custom graph node is a different story.

## K2Node and what are they?

Kismet was the first visual scripting language in the engine. It was first introduced with Unreal Engine 3, then Kismet 2 came along and turned into Blueprint, which is what we have today. So that is why you'll see K2 (Kismet 2) in some places of the engine. 

This naturally brings us to K2Node (Kismet 2 Node), the parent class for all nodes used for Blueprint graphs. Most of the nodes you see in the graph, inherits from **UK2Node_CallFunction**.

K2Nodes are very advanced Blueprint nodes that can go beyond the specifiers of [UFUNCTION](https://benui.ca/unreal/ufunction/) / [UPARAM](https://benui.ca/unreal/uparam/) and give the developer full control of how it behaves, but 99% of the time, the specifiers are enough.

A great example of a custom Blueprint node is all construct nodes such as **Spawn Actor From Class** and **Construct Object From Class**, which greatly reduces the spaghetti of Blueprint graphs.

Spawn Actor consists of two Blueprint nodes, BeginDeferredActorSpawnFromClass and FinishSpawningActor, and for each variable, you mark as ExposeOnSpawn, the Blueprint compiler generates another Blueprint setter node. So the execution order for a SpawnActor node is:

```javascript
BeginDeferredActorSpawnFromClass ->
Generated Blueprint node setters for ExposeOnSpawn variables ->
FinishSpawningActor
``` 
You can think of K2Nodes as subgraphs that can contain multiple nodes.

I'd suggest checking out **UK2Node_SpawnActorFromClass** as it is relatively straight forward with plenty of comments to understand what's happening.

## Lets make a custom K2Node

This post assumes you are familiar with Unreal Engine and C++, so I won't cover the class creation steps. But you need an UncookedOnly module and a class that inherits from UK2Node. 

In this blog post we will make a IsValid node from scratch with a custom K2Node.

To create a K2Node from scratch, does require a lot of functions to override to get started.

```javascript
//Gets the name of this node, shown in title bar of the node.
virtual FText GetNodeTitle(ENodeTitleType::Type TitleType) const;

//Gets the tooltip that will be shown when the node is hovered
virtual FText GetTooltipText() const;

//Override to provide a default category for specific node types to be listed under.
virtual FText GetMenuCategory() const;

//Adds the node to the context menu
virtual void GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const;

//Allocate default pins for a given node, based only the NodeType, which should already be filled in.
virtual void AllocateDefaultPins()

//Expands a node while compiling, which may add additional nodes or delete this node.
virtual void ExpandNode(class FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph);
``` 

Lets start with the basic functions. Your custom K2Node class header should look like this to begin with:

```javascript
UCLASS()
class UK2Node_IsValid : public UK2Node
{
	GENERATED_BODY()

	//Start of UEdGraphNode interface implementation
	virtual FText GetNodeTitle(ENodeTitleType::Type TitleType) const override;
	virtual FText GetTooltipText() const override;
	//End of implementation

	//Start of UK2Node interface implementation
	virtual FText GetMenuCategory() const override;
	//End of implementation
};
```

Lets start by implementing them in .cpp

```javascript
FText UK2Node_IsValid::GetMenuCategory() const
{
	return LOCTEXT("K2Node_IsValid_Category", "Validity");
}

FText UK2Node_IsValid::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	return LOCTEXT("K2Node_IsValid_NodeTitle", "Is Valid");
}

FText UK2Node_IsValid::GetTooltipText() const
{
	return LOCTEXT("K2Node_IsValid_TooltipText", "Determines if an object is valid");
}
```

These functions are just cosmetics, but are essential in the sense that they are important for the UX of the node.

Now compile and open any Blueprint graph and search for the name you gave the GetNodeTitle function, you might realize you can't find the node in the list. Because we're missing a vital override.

Add this to the header:

```javascript
virtual void GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const override;
```

...And this to the .cpp: 

```javascript
void UK2Node_IsValid::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
	Super::GetMenuActions(ActionRegistrar);
	UClass* Action = GetClass();
	if (ActionRegistrar.IsOpenForRegistration(Action))
	{
		UBlueprintNodeSpawner* Spawner = UBlueprintNodeSpawner::Create(GetClass());
		ActionRegistrar.AddBlueprintAction(Action, Spawner);
	}
}
```

Your node is now fully setup with title, category, tooltip, and you can find it in the node list. It should now look like this when you add it to a Blueprint graph:

![K2NodeIsValidWithoutPins](https://raw.githubusercontent.com/OlssonDev/olssondev.github.io/master/assets/img/K2NodeIsValidWithoutPins.JPG)

## Populate the node with pins

Our node is empty and can't be interacted with other pins. To add pins so it starts to look more like a Blueprint node, you need to override this function I mentioned earlier:

```javascript
virtual void AllocateDefaultPins() override;
``` 

AllocateDefaultPins is where you declare all your pins for your nodes. Everything from a float pin to an execute pin.

Let's add the most important pin for a Blueprint node we want to execute, the execute pin or ExecPin as it's called in K2Node terms.

```javascript
//Version 1
void UK2Node_IsValid::AllocateDefaultPins()
{
	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Execute);
}

// Version 2
void UK2Node_IsValid::AllocateDefaultPins()
{
	CreatePin(EGPD_Input, TEXT("exec"), TEXT("execute"));
}
``` 

As you can see above, we have two versions of making an ExecPin, and both are valid in the sense that they work, but Version 1 is the better alternative. 

**UEdGraphSchema_K2** is a great class to get names of different pin types and should be used when choosing the pin's **PinCategory**.

Now compile and see what happened with the node.

![K2NodeIsValidWithExecPin](https://raw.githubusercontent.com/OlssonDev/olssondev.github.io/master/assets/img/K2NodeIsValidWithExecPin.JPG)

Your node now has an execute pin that is connectable. How cool! :D

**In progress...**